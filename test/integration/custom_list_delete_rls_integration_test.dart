import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:prioris/main.dart' as app;
import 'package:prioris/domain/models/core/entities/custom_list.dart';
import 'package:prioris/domain/models/core/enums/list_enums.dart';
import 'package:prioris/data/repositories/custom_list_repository.dart';
import 'package:prioris/infrastructure/services/auth_service.dart';
import 'package:prioris/infrastructure/config/app_config.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

/// Test d'int√©gration pour valider la suppression de listes avec RLS
/// 
/// Ce test valide le workflow complet :
/// 1. Authentification utilisateur
/// 2. Cr√©ation d'une liste de test
/// 3. Suppression de la liste
/// 4. V√©rification que la suppression cloud fonctionne
/// 5. Validation que la liste ne r√©appara√Æt pas apr√®s red√©marrage
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Suppression de Liste - Test RLS Int√©gration', () {
    late ProviderContainer container;
    late CustomListRepository repository;
    late AuthService authService;
    
    const testUserEmail = 'test-delete@prioris.app';
    const testUserPassword = 'TestDelete123!';

    setUpAll(() async {
      // Initialiser la configuration
      await AppConfig.initialize();
      
      // Cr√©er le container Riverpod
      container = ProviderContainer();
      
      // R√©cup√©rer les services
      authService = AuthService.instance;
      
      // Note: En environnement de test, utiliser le repository Supabase directement
      // repository = container.read(customListRepositoryProvider);
    });

    tearDownAll(() {
      container.dispose();
    });

    group('Workflow complet de suppression', () {
      testWidgets('DOIT supprimer une liste et la garder supprim√©e apr√®s red√©marrage', (WidgetTester tester) async {
        // ====================================
        // √âTAPE 1: AUTHENTIFICATION
        // ====================================
        
        // Se connecter avec un utilisateur de test
        try {
          await authService.signInWithEmailAndPassword(
            testUserEmail, 
            testUserPassword,
          );
        } catch (e) {
          // Si l'utilisateur n'existe pas, le cr√©er
          await authService.signUpWithEmailAndPassword(
            testUserEmail, 
            testUserPassword,
          );
        }

        // V√©rifier l'authentification
        expect(authService.isSignedIn, isTrue, 
          reason: 'L\'utilisateur doit √™tre authentifi√©');
        expect(authService.currentUser?.email, equals(testUserEmail));

        // ====================================
        // √âTAPE 2: CR√âATION DE LISTE DE TEST
        // ====================================
        
        final testList = CustomList(
          id: const Uuid().v4(),
          title: 'Liste Test Suppression RLS',
          description: 'Liste cr√©√©e pour tester la suppression avec RLS',
          listType: ListType.CUSTOM,
          color: 0xFF2196F3,
          icon: 0xe5ca,
          items: [],
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        // Sauvegarder la liste
        await repository.saveList(testList);
        
        // V√©rifier que la liste est cr√©√©e
        final createdList = await repository.getListById(testList.id);
        expect(createdList, isNotNull, 
          reason: 'La liste doit √™tre cr√©√©e avec succ√®s');
        expect(createdList!.title, equals(testList.title));

        // ====================================
        // √âTAPE 3: SUPPRESSION DE LA LISTE  
        // ====================================
        
        // Supprimer la liste
        await repository.deleteList(testList.id);

        // V√©rifier que la liste n'est plus accessible (soft delete)
        final deletedList = await repository.getListById(testList.id);
        expect(deletedList, isNull, 
          reason: 'La liste supprim√©e ne doit plus √™tre accessible');

        // V√©rifier que la liste n'appara√Æt plus dans getAllLists
        final allLists = await repository.getAllLists();
        final foundList = allLists.any((list) => list.id == testList.id);
        expect(foundList, isFalse, 
          reason: 'La liste supprim√©e ne doit plus appara√Ætre dans getAllLists');

        // ====================================
        // √âTAPE 4: VALIDATION PERSISTANCE CLOUD
        // ====================================
        
        // Attendre un peu pour la propagation
        await tester.pump(const Duration(seconds: 2));

        // Forcer un reload depuis le cloud
        final reloadedLists = await repository.getAllLists();
        final stillExists = reloadedLists.any((list) => list.id == testList.id);
        expect(stillExists, isFalse, 
          reason: 'La liste ne doit plus exister apr√®s reload cloud');

        // ====================================
        // √âTAPE 5: SIMULATION RED√âMARRAGE APP
        // ====================================
        
        // Simuler un red√©marrage en r√©initialisant et rechargeant
        // (Dans un vrai test d'int√©gration, on relancerait l'app)
        
        // Se d√©connecter et reconnecter
        await authService.signOut();
        expect(authService.isSignedIn, isFalse);
        
        await authService.signInWithEmailAndPassword(
          testUserEmail, 
          testUserPassword,
        );
        expect(authService.isSignedIn, isTrue);

        // Recharger les listes apr√®s "red√©marrage"
        final postRestartLists = await repository.getAllLists();
        final listStillGone = postRestartLists.every((list) => list.id != testList.id);
        expect(listStillGone, isTrue, 
          reason: 'La liste doit rester supprim√©e m√™me apr√®s red√©marrage');

        print('‚úÖ Test de suppression RLS r√©ussi !');
        print('üìä Listes trouv√©es apr√®s suppression: ${postRestartLists.length}');
      });

      testWidgets('DOIT √©chouer la suppression d\'une liste d\'un autre utilisateur', (WidgetTester tester) async {
        // ====================================
        // √âTAPE 1: CR√âER UNE LISTE AVEC USER 1
        // ====================================
        
        // Se connecter avec le premier utilisateur
        await authService.signInWithEmailAndPassword(
          testUserEmail, 
          testUserPassword,
        );
        
        final testList = CustomList(
          id: const Uuid().v4(),
          title: 'Liste Utilisateur 1',
          description: 'Liste qui ne doit pas √™tre supprimable par user 2',
          listType: ListType.CUSTOM,
          color: 0xFF2196F3,
          icon: 0xe5ca,
          items: [],
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        await repository.saveList(testList);
        final listId = testList.id;

        // ====================================
        // √âTAPE 2: ESSAYER DE SUPPRIMER AVEC USER 2
        // ====================================
        
        // Se d√©connecter du user 1
        await authService.signOut();
        
        // Se connecter avec un autre utilisateur
        const otherUserEmail = 'other-test@prioris.app';
        const otherUserPassword = 'OtherTest123!';
        
        try {
          await authService.signInWithEmailAndPassword(
            otherUserEmail, 
            otherUserPassword,
          );
        } catch (e) {
          await authService.signUpWithEmailAndPassword(
            otherUserEmail, 
            otherUserPassword,
          );
        }

        // Essayer de supprimer la liste de l'autre utilisateur
        // Cela DOIT √©chouer gr√¢ce aux politiques RLS
        await expectLater(
          repository.deleteList(listId),
          throwsA(isA<Exception>()),
          reason: 'La suppression d\'une liste d\'un autre utilisateur doit √©chouer',
        );

        // ====================================
        // √âTAPE 3: V√âRIFIER QUE LA LISTE EXISTE TOUJOURS
        // ====================================
        
        // Se reconnecter avec le user 1 original
        await authService.signOut();
        await authService.signInWithEmailAndPassword(
          testUserEmail, 
          testUserPassword,
        );

        // V√©rifier que la liste existe toujours
        final stillExistingList = await repository.getListById(listId);
        expect(stillExistingList, isNotNull, 
          reason: 'La liste doit toujours exister car la suppression par l\'autre user a √©chou√©');
        
        // Nettoyer - supprimer la liste avec le bon utilisateur
        await repository.deleteList(listId);
        
        print('‚úÖ Test de s√©curit√© RLS r√©ussi !');
      });
    });

    group('Tests de performance et robustesse', () {
      testWidgets('DOIT g√©rer la suppression de multiples listes', (WidgetTester tester) async {
        // Authentification
        await authService.signInWithEmailAndPassword(
          testUserEmail, 
          testUserPassword,
        );

        // Cr√©er plusieurs listes
        final testLists = <CustomList>[];
        for (int i = 0; i < 5; i++) {
          final list = CustomList(
            id: const Uuid().v4(),
            title: 'Liste Test Bulk $i',
            description: 'Liste $i pour test suppression en masse',
            listType: ListType.CUSTOM,
            color: 0xFF2196F3,
            icon: 0xe5ca,
            items: [],
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          );
          testLists.add(list);
          await repository.saveList(list);
        }

        // V√©rifier que toutes sont cr√©√©es
        final allListsBeforeDelete = await repository.getAllLists();
        for (final list in testLists) {
          expect(
            allListsBeforeDelete.any((l) => l.id == list.id), 
            isTrue,
            reason: 'Liste ${list.title} doit exister avant suppression',
          );
        }

        // Supprimer toutes les listes
        for (final list in testLists) {
          await repository.deleteList(list.id);
        }

        // V√©rifier que toutes sont supprim√©es
        final allListsAfterDelete = await repository.getAllLists();
        for (final list in testLists) {
          expect(
            allListsAfterDelete.any((l) => l.id == list.id), 
            isFalse,
            reason: 'Liste ${list.title} doit √™tre supprim√©e',
          );
        }

        print('‚úÖ Test de suppression en masse r√©ussi !');
        print('üìä ${testLists.length} listes supprim√©es avec succ√®s');
      });
    });
  });
}